import commands2
from wpilib import SmartDashboard

from subsystems.pneumatics import Pneumatics
from subsystems.wrist import Wrist
from subsystems.elevator import Elevator
from subsystems.arm import Arm
from playingwithfusion import TimeOfFlight
from subsystems.vision import Vision

from commands.elevator_move import ElevatorMove
from commands.manipulator_auto_grab import ManipulatorAutoGrab

class ToggleGroundPickupJR(commands2.CommandBase):
    def __init__(self, container, pneumatics: Pneumatics, wrist: Wrist, arm: Arm, elevator: Elevator, vision: Vision, pick_up_cone: bool, tolerance=5) -> None:
        super().__init__()
        self.setName('ToggleGroundPickupJR')

        self.container = container
        self.penumatics = pneumatics
        self.wrist = wrist
        self.arm = arm
        self.elevator = elevator
        self.vision = Vision
        
        self.has_game_piece = False
        self.pick_up_cone = pick_up_cone #determines if we're picking up a cone or picking up a block (pneumatics & wrist height changes based on this)

        self.distance_sensor = TimeOfFlight(13)  # ships with an ID of 0.  #The ToF has an absolute proximity sensing from 30mm to ~1000mm.  Can measure to a millimiter accuracy.
        self.distance_sensor.setRangingMode(TimeOfFlight.RangingMode.kMedium, 50)
        # self.distance_sensor.setRangeOfInterest()

        self.tolerance = tolerance 

        self.phaseOneFinished = False #honing onto gamepiece and lowering elevator
        self.phaseTwoFinished = False #extending arm & adjusting writs if necessary
        self.phaseThreeFinished = False #clamping gamepiece

        self.median_filter = MedianFilter(5)

    def initialize(self) -> None:
        #detect game piece, determine how far off it's from the center
        self.angle_of_game_piece = None

        #if the ToF doesn't detect a game piece, or if the camera detects that it's out of range for the turret to rotate to, DO NOT START.

        # open manipulator
        self.pneumatics.set_manipulator_piston(position='open')
        
        # deploy wrist
        self.wrist.set_wrist_angle(angle=self.wrist.positions['floor'])

        self.elevator.set_elevator_height(0) #i have no idea what the actual height value is...
        self.turret.set_turret_angle(self.angle_of_game_piece)

    def execute(self) -> None:
        if not phaseOneFinished:
            phaseOneFinished = abs(elevator.get_height() < self.tolerance) and abs(turret.get_angle - self.angle_of_game_piece) < self.tolerance

        if phaseOneFinished and not phaseTwoFinished:
            distance = self.median_filter.calculate(distance_sensor.getRange()) 
            self.arm.set_arm_extension(distance)

            phaseTwoFinished = abs(self.arm.get_extension() - distance) < self.tolerance and abs(self.wrist.get_angle - self.wrist.positions['floor']) < self.tolerance


        if phaseOneFinished and phaseTwoFinished and not phaseThreeFinished:
            #pneumatics clamp
            self.pneumatics.set_manipulator_piston(position='close')
            # phaseThreeFinished = 
            #not sure what the stop condition for this is...(I would rather avoid a timer)

        #To Do: if <some button> is pressed, ABANDON THIS COMMAND AND STOW WRIST.  (Not sure if the process of checking the button happens inside or outside this...)
        pass

    def isFinished(self) -> bool:
        return phaseOneFinished and phaseTwoFinished and phaseThreeFinished
    def end(self, interrupted: bool) -> None:
        # stow wrist
        # not sure what the best order of things is (unless we can move everything at the same time)

        end_time = self.container.get_enabled_time()
        message = 'Interrupted' if interrupted else 'Ended'
        print(f'** {message} {self.getName()} at {end_time:.1f} s after {end_time - self.start_time:.1f} s **')

    def print_start_message(self) -> None:
        self.start_time = round(self.container.get_enabled_time(), 2)
        print("\n" + f"** Started {self.getName()} at {self.start_time} s **", flush=True)
        SmartDashboard.putString("alert", f"** Started {self.getName()} at {self.start_time - self.container.get_enabled_time():2.2f} s **")
